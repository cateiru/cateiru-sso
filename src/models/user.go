// Code generated by SQLBoiler 4.14.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID         string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	UserName   string      `boil:"user_name" json:"user_name" toml:"user_name" yaml:"user_name"`
	Email      string      `boil:"email" json:"email" toml:"email" yaml:"email"`
	FamilyName null.String `boil:"family_name" json:"family_name,omitempty" toml:"family_name" yaml:"family_name,omitempty"`
	MiddleName null.String `boil:"middle_name" json:"middle_name,omitempty" toml:"middle_name" yaml:"middle_name,omitempty"`
	GivenName  null.String `boil:"given_name" json:"given_name,omitempty" toml:"given_name" yaml:"given_name,omitempty"`
	Gender     string      `boil:"gender" json:"gender" toml:"gender" yaml:"gender"`
	Birthdate  null.Time   `boil:"birthdate" json:"birthdate,omitempty" toml:"birthdate" yaml:"birthdate,omitempty"`
	Avatar     null.String `boil:"avatar" json:"avatar,omitempty" toml:"avatar" yaml:"avatar,omitempty"`
	LocaleID   string      `boil:"locale_id" json:"locale_id" toml:"locale_id" yaml:"locale_id"`
	CreatedAt  time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	ModifiedAt time.Time   `boil:"modified_at" json:"modified_at" toml:"modified_at" yaml:"modified_at"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID         string
	UserName   string
	Email      string
	FamilyName string
	MiddleName string
	GivenName  string
	Gender     string
	Birthdate  string
	Avatar     string
	LocaleID   string
	CreatedAt  string
	ModifiedAt string
}{
	ID:         "id",
	UserName:   "user_name",
	Email:      "email",
	FamilyName: "family_name",
	MiddleName: "middle_name",
	GivenName:  "given_name",
	Gender:     "gender",
	Birthdate:  "birthdate",
	Avatar:     "avatar",
	LocaleID:   "locale_id",
	CreatedAt:  "created_at",
	ModifiedAt: "modified_at",
}

var UserTableColumns = struct {
	ID         string
	UserName   string
	Email      string
	FamilyName string
	MiddleName string
	GivenName  string
	Gender     string
	Birthdate  string
	Avatar     string
	LocaleID   string
	CreatedAt  string
	ModifiedAt string
}{
	ID:         "user.id",
	UserName:   "user.user_name",
	Email:      "user.email",
	FamilyName: "user.family_name",
	MiddleName: "user.middle_name",
	GivenName:  "user.given_name",
	Gender:     "user.gender",
	Birthdate:  "user.birthdate",
	Avatar:     "user.avatar",
	LocaleID:   "user.locale_id",
	CreatedAt:  "user.created_at",
	ModifiedAt: "user.modified_at",
}

// Generated where

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var UserWhere = struct {
	ID         whereHelperstring
	UserName   whereHelperstring
	Email      whereHelperstring
	FamilyName whereHelpernull_String
	MiddleName whereHelpernull_String
	GivenName  whereHelpernull_String
	Gender     whereHelperstring
	Birthdate  whereHelpernull_Time
	Avatar     whereHelpernull_String
	LocaleID   whereHelperstring
	CreatedAt  whereHelpertime_Time
	ModifiedAt whereHelpertime_Time
}{
	ID:         whereHelperstring{field: "`user`.`id`"},
	UserName:   whereHelperstring{field: "`user`.`user_name`"},
	Email:      whereHelperstring{field: "`user`.`email`"},
	FamilyName: whereHelpernull_String{field: "`user`.`family_name`"},
	MiddleName: whereHelpernull_String{field: "`user`.`middle_name`"},
	GivenName:  whereHelpernull_String{field: "`user`.`given_name`"},
	Gender:     whereHelperstring{field: "`user`.`gender`"},
	Birthdate:  whereHelpernull_Time{field: "`user`.`birthdate`"},
	Avatar:     whereHelpernull_String{field: "`user`.`avatar`"},
	LocaleID:   whereHelperstring{field: "`user`.`locale_id`"},
	CreatedAt:  whereHelpertime_Time{field: "`user`.`created_at`"},
	ModifiedAt: whereHelpertime_Time{field: "`user`.`modified_at`"},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	Otp                  string
	Password             string
	Setting              string
	Staff                string
	BroadcastNotices     string
	CertificateSessions  string
	OwnerUserClients     string
	ClientRefreshes      string
	ClientSessions       string
	EmailVerifySessions  string
	LoginClientHistories string
	LoginHistories       string
	LoginTryHistories    string
	OauthSessions        string
	OtpBackups           string
	OtpSessions          string
	Refreshes            string
	RegisterOtpSessions  string
	Sessions             string
	UserBrands           string
	Webauthns            string
}{
	Otp:                  "Otp",
	Password:             "Password",
	Setting:              "Setting",
	Staff:                "Staff",
	BroadcastNotices:     "BroadcastNotices",
	CertificateSessions:  "CertificateSessions",
	OwnerUserClients:     "OwnerUserClients",
	ClientRefreshes:      "ClientRefreshes",
	ClientSessions:       "ClientSessions",
	EmailVerifySessions:  "EmailVerifySessions",
	LoginClientHistories: "LoginClientHistories",
	LoginHistories:       "LoginHistories",
	LoginTryHistories:    "LoginTryHistories",
	OauthSessions:        "OauthSessions",
	OtpBackups:           "OtpBackups",
	OtpSessions:          "OtpSessions",
	Refreshes:            "Refreshes",
	RegisterOtpSessions:  "RegisterOtpSessions",
	Sessions:             "Sessions",
	UserBrands:           "UserBrands",
	Webauthns:            "Webauthns",
}

// userR is where relationships are stored.
type userR struct {
	Otp                  *Otp                    `boil:"Otp" json:"Otp" toml:"Otp" yaml:"Otp"`
	Password             *Password               `boil:"Password" json:"Password" toml:"Password" yaml:"Password"`
	Setting              *Setting                `boil:"Setting" json:"Setting" toml:"Setting" yaml:"Setting"`
	Staff                *Staff                  `boil:"Staff" json:"Staff" toml:"Staff" yaml:"Staff"`
	BroadcastNotices     BroadcastNoticeSlice    `boil:"BroadcastNotices" json:"BroadcastNotices" toml:"BroadcastNotices" yaml:"BroadcastNotices"`
	CertificateSessions  CertificateSessionSlice `boil:"CertificateSessions" json:"CertificateSessions" toml:"CertificateSessions" yaml:"CertificateSessions"`
	OwnerUserClients     ClientSlice             `boil:"OwnerUserClients" json:"OwnerUserClients" toml:"OwnerUserClients" yaml:"OwnerUserClients"`
	ClientRefreshes      ClientRefreshSlice      `boil:"ClientRefreshes" json:"ClientRefreshes" toml:"ClientRefreshes" yaml:"ClientRefreshes"`
	ClientSessions       ClientSessionSlice      `boil:"ClientSessions" json:"ClientSessions" toml:"ClientSessions" yaml:"ClientSessions"`
	EmailVerifySessions  EmailVerifySessionSlice `boil:"EmailVerifySessions" json:"EmailVerifySessions" toml:"EmailVerifySessions" yaml:"EmailVerifySessions"`
	LoginClientHistories LoginClientHistorySlice `boil:"LoginClientHistories" json:"LoginClientHistories" toml:"LoginClientHistories" yaml:"LoginClientHistories"`
	LoginHistories       LoginHistorySlice       `boil:"LoginHistories" json:"LoginHistories" toml:"LoginHistories" yaml:"LoginHistories"`
	LoginTryHistories    LoginTryHistorySlice    `boil:"LoginTryHistories" json:"LoginTryHistories" toml:"LoginTryHistories" yaml:"LoginTryHistories"`
	OauthSessions        OauthSessionSlice       `boil:"OauthSessions" json:"OauthSessions" toml:"OauthSessions" yaml:"OauthSessions"`
	OtpBackups           OtpBackupSlice          `boil:"OtpBackups" json:"OtpBackups" toml:"OtpBackups" yaml:"OtpBackups"`
	OtpSessions          OtpSessionSlice         `boil:"OtpSessions" json:"OtpSessions" toml:"OtpSessions" yaml:"OtpSessions"`
	Refreshes            RefreshSlice            `boil:"Refreshes" json:"Refreshes" toml:"Refreshes" yaml:"Refreshes"`
	RegisterOtpSessions  RegisterOtpSessionSlice `boil:"RegisterOtpSessions" json:"RegisterOtpSessions" toml:"RegisterOtpSessions" yaml:"RegisterOtpSessions"`
	Sessions             SessionSlice            `boil:"Sessions" json:"Sessions" toml:"Sessions" yaml:"Sessions"`
	UserBrands           UserBrandSlice          `boil:"UserBrands" json:"UserBrands" toml:"UserBrands" yaml:"UserBrands"`
	Webauthns            WebauthnSlice           `boil:"Webauthns" json:"Webauthns" toml:"Webauthns" yaml:"Webauthns"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (r *userR) GetOtp() *Otp {
	if r == nil {
		return nil
	}
	return r.Otp
}

func (r *userR) GetPassword() *Password {
	if r == nil {
		return nil
	}
	return r.Password
}

func (r *userR) GetSetting() *Setting {
	if r == nil {
		return nil
	}
	return r.Setting
}

func (r *userR) GetStaff() *Staff {
	if r == nil {
		return nil
	}
	return r.Staff
}

func (r *userR) GetBroadcastNotices() BroadcastNoticeSlice {
	if r == nil {
		return nil
	}
	return r.BroadcastNotices
}

func (r *userR) GetCertificateSessions() CertificateSessionSlice {
	if r == nil {
		return nil
	}
	return r.CertificateSessions
}

func (r *userR) GetOwnerUserClients() ClientSlice {
	if r == nil {
		return nil
	}
	return r.OwnerUserClients
}

func (r *userR) GetClientRefreshes() ClientRefreshSlice {
	if r == nil {
		return nil
	}
	return r.ClientRefreshes
}

func (r *userR) GetClientSessions() ClientSessionSlice {
	if r == nil {
		return nil
	}
	return r.ClientSessions
}

func (r *userR) GetEmailVerifySessions() EmailVerifySessionSlice {
	if r == nil {
		return nil
	}
	return r.EmailVerifySessions
}

func (r *userR) GetLoginClientHistories() LoginClientHistorySlice {
	if r == nil {
		return nil
	}
	return r.LoginClientHistories
}

func (r *userR) GetLoginHistories() LoginHistorySlice {
	if r == nil {
		return nil
	}
	return r.LoginHistories
}

func (r *userR) GetLoginTryHistories() LoginTryHistorySlice {
	if r == nil {
		return nil
	}
	return r.LoginTryHistories
}

func (r *userR) GetOauthSessions() OauthSessionSlice {
	if r == nil {
		return nil
	}
	return r.OauthSessions
}

func (r *userR) GetOtpBackups() OtpBackupSlice {
	if r == nil {
		return nil
	}
	return r.OtpBackups
}

func (r *userR) GetOtpSessions() OtpSessionSlice {
	if r == nil {
		return nil
	}
	return r.OtpSessions
}

func (r *userR) GetRefreshes() RefreshSlice {
	if r == nil {
		return nil
	}
	return r.Refreshes
}

func (r *userR) GetRegisterOtpSessions() RegisterOtpSessionSlice {
	if r == nil {
		return nil
	}
	return r.RegisterOtpSessions
}

func (r *userR) GetSessions() SessionSlice {
	if r == nil {
		return nil
	}
	return r.Sessions
}

func (r *userR) GetUserBrands() UserBrandSlice {
	if r == nil {
		return nil
	}
	return r.UserBrands
}

func (r *userR) GetWebauthns() WebauthnSlice {
	if r == nil {
		return nil
	}
	return r.Webauthns
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "user_name", "email", "family_name", "middle_name", "given_name", "gender", "birthdate", "avatar", "locale_id", "created_at", "modified_at"}
	userColumnsWithoutDefault = []string{"id", "email", "family_name", "middle_name", "given_name", "birthdate", "avatar"}
	userColumnsWithDefault    = []string{"user_name", "gender", "locale_id", "created_at", "modified_at"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userAfterSelectHooks []UserHook

var userBeforeInsertHooks []UserHook
var userAfterInsertHooks []UserHook

var userBeforeUpdateHooks []UserHook
var userAfterUpdateHooks []UserHook

var userBeforeDeleteHooks []UserHook
var userAfterDeleteHooks []UserHook

var userBeforeUpsertHooks []UserHook
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
	case boil.BeforeInsertHook:
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
	case boil.AfterInsertHook:
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
	case boil.BeforeUpdateHook:
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
	case boil.AfterUpdateHook:
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
	case boil.BeforeDeleteHook:
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
	case boil.AfterDeleteHook:
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
	case boil.BeforeUpsertHook:
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
	case boil.AfterUpsertHook:
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for user")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count user rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if user exists")
	}

	return count > 0, nil
}

// Otp pointed to by the foreign key.
func (o *User) Otp(mods ...qm.QueryMod) otpQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`user_id` = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Otps(queryMods...)
}

// Password pointed to by the foreign key.
func (o *User) Password(mods ...qm.QueryMod) passwordQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`user_id` = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Passwords(queryMods...)
}

// Setting pointed to by the foreign key.
func (o *User) Setting(mods ...qm.QueryMod) settingQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`user_id` = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Settings(queryMods...)
}

// Staff pointed to by the foreign key.
func (o *User) Staff(mods ...qm.QueryMod) staffQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`user_id` = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Staffs(queryMods...)
}

// BroadcastNotices retrieves all the broadcast_notice's BroadcastNotices with an executor.
func (o *User) BroadcastNotices(mods ...qm.QueryMod) broadcastNoticeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`broadcast_notice`.`user_id`=?", o.ID),
	)

	return BroadcastNotices(queryMods...)
}

// CertificateSessions retrieves all the certificate_session's CertificateSessions with an executor.
func (o *User) CertificateSessions(mods ...qm.QueryMod) certificateSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`certificate_session`.`user_id`=?", o.ID),
	)

	return CertificateSessions(queryMods...)
}

// OwnerUserClients retrieves all the client's Clients with an executor via owner_user_id column.
func (o *User) OwnerUserClients(mods ...qm.QueryMod) clientQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`client`.`owner_user_id`=?", o.ID),
	)

	return Clients(queryMods...)
}

// ClientRefreshes retrieves all the client_refresh's ClientRefreshes with an executor.
func (o *User) ClientRefreshes(mods ...qm.QueryMod) clientRefreshQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`client_refresh`.`user_id`=?", o.ID),
	)

	return ClientRefreshes(queryMods...)
}

// ClientSessions retrieves all the client_session's ClientSessions with an executor.
func (o *User) ClientSessions(mods ...qm.QueryMod) clientSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`client_session`.`user_id`=?", o.ID),
	)

	return ClientSessions(queryMods...)
}

// EmailVerifySessions retrieves all the email_verify_session's EmailVerifySessions with an executor.
func (o *User) EmailVerifySessions(mods ...qm.QueryMod) emailVerifySessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`email_verify_session`.`user_id`=?", o.ID),
	)

	return EmailVerifySessions(queryMods...)
}

// LoginClientHistories retrieves all the login_client_history's LoginClientHistories with an executor.
func (o *User) LoginClientHistories(mods ...qm.QueryMod) loginClientHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`login_client_history`.`user_id`=?", o.ID),
	)

	return LoginClientHistories(queryMods...)
}

// LoginHistories retrieves all the login_history's LoginHistories with an executor.
func (o *User) LoginHistories(mods ...qm.QueryMod) loginHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`login_history`.`user_id`=?", o.ID),
	)

	return LoginHistories(queryMods...)
}

// LoginTryHistories retrieves all the login_try_history's LoginTryHistories with an executor.
func (o *User) LoginTryHistories(mods ...qm.QueryMod) loginTryHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`login_try_history`.`user_id`=?", o.ID),
	)

	return LoginTryHistories(queryMods...)
}

// OauthSessions retrieves all the oauth_session's OauthSessions with an executor.
func (o *User) OauthSessions(mods ...qm.QueryMod) oauthSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`oauth_session`.`user_id`=?", o.ID),
	)

	return OauthSessions(queryMods...)
}

// OtpBackups retrieves all the otp_backup's OtpBackups with an executor.
func (o *User) OtpBackups(mods ...qm.QueryMod) otpBackupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`otp_backup`.`user_id`=?", o.ID),
	)

	return OtpBackups(queryMods...)
}

// OtpSessions retrieves all the otp_session's OtpSessions with an executor.
func (o *User) OtpSessions(mods ...qm.QueryMod) otpSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`otp_session`.`user_id`=?", o.ID),
	)

	return OtpSessions(queryMods...)
}

// Refreshes retrieves all the refresh's Refreshes with an executor.
func (o *User) Refreshes(mods ...qm.QueryMod) refreshQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`refresh`.`user_id`=?", o.ID),
	)

	return Refreshes(queryMods...)
}

// RegisterOtpSessions retrieves all the register_otp_session's RegisterOtpSessions with an executor.
func (o *User) RegisterOtpSessions(mods ...qm.QueryMod) registerOtpSessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`register_otp_session`.`user_id`=?", o.ID),
	)

	return RegisterOtpSessions(queryMods...)
}

// Sessions retrieves all the session's Sessions with an executor.
func (o *User) Sessions(mods ...qm.QueryMod) sessionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`session`.`user_id`=?", o.ID),
	)

	return Sessions(queryMods...)
}

// UserBrands retrieves all the user_brand's UserBrands with an executor.
func (o *User) UserBrands(mods ...qm.QueryMod) userBrandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`user_brand`.`user_id`=?", o.ID),
	)

	return UserBrands(queryMods...)
}

// Webauthns retrieves all the webauthn's Webauthns with an executor.
func (o *User) Webauthns(mods ...qm.QueryMod) webauthnQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`webauthn`.`user_id`=?", o.ID),
	)

	return Webauthns(queryMods...)
}

// LoadOtp allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadOtp(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`otp`),
		qm.WhereIn(`otp.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Otp")
	}

	var resultSlice []*Otp
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Otp")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for otp")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for otp")
	}

	if len(otpAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Otp = foreign
		if foreign.R == nil {
			foreign.R = &otpR{}
		}
		foreign.R.User = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserID {
				local.R.Otp = foreign
				if foreign.R == nil {
					foreign.R = &otpR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadPassword allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadPassword(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`password`),
		qm.WhereIn(`password.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Password")
	}

	var resultSlice []*Password
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Password")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for password")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for password")
	}

	if len(passwordAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Password = foreign
		if foreign.R == nil {
			foreign.R = &passwordR{}
		}
		foreign.R.User = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserID {
				local.R.Password = foreign
				if foreign.R == nil {
					foreign.R = &passwordR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadSetting allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadSetting(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`setting`),
		qm.WhereIn(`setting.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Setting")
	}

	var resultSlice []*Setting
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Setting")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for setting")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for setting")
	}

	if len(settingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Setting = foreign
		if foreign.R == nil {
			foreign.R = &settingR{}
		}
		foreign.R.User = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserID {
				local.R.Setting = foreign
				if foreign.R == nil {
					foreign.R = &settingR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadStaff allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadStaff(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`staff`),
		qm.WhereIn(`staff.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Staff")
	}

	var resultSlice []*Staff
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Staff")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for staff")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staff")
	}

	if len(staffAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Staff = foreign
		if foreign.R == nil {
			foreign.R = &staffR{}
		}
		foreign.R.User = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserID {
				local.R.Staff = foreign
				if foreign.R == nil {
					foreign.R = &staffR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadBroadcastNotices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadBroadcastNotices(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`broadcast_notice`),
		qm.WhereIn(`broadcast_notice.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load broadcast_notice")
	}

	var resultSlice []*BroadcastNotice
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice broadcast_notice")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on broadcast_notice")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for broadcast_notice")
	}

	if len(broadcastNoticeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BroadcastNotices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &broadcastNoticeR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.BroadcastNotices = append(local.R.BroadcastNotices, foreign)
				if foreign.R == nil {
					foreign.R = &broadcastNoticeR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCertificateSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCertificateSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`certificate_session`),
		qm.WhereIn(`certificate_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load certificate_session")
	}

	var resultSlice []*CertificateSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice certificate_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on certificate_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for certificate_session")
	}

	if len(certificateSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CertificateSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &certificateSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.CertificateSessions = append(local.R.CertificateSessions, foreign)
				if foreign.R == nil {
					foreign.R = &certificateSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerUserClients allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOwnerUserClients(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`client`),
		qm.WhereIn(`client.owner_user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load client")
	}

	var resultSlice []*Client
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice client")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on client")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for client")
	}

	if len(clientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerUserClients = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &clientR{}
			}
			foreign.R.OwnerUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerUserID {
				local.R.OwnerUserClients = append(local.R.OwnerUserClients, foreign)
				if foreign.R == nil {
					foreign.R = &clientR{}
				}
				foreign.R.OwnerUser = local
				break
			}
		}
	}

	return nil
}

// LoadClientRefreshes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadClientRefreshes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`client_refresh`),
		qm.WhereIn(`client_refresh.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load client_refresh")
	}

	var resultSlice []*ClientRefresh
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice client_refresh")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on client_refresh")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for client_refresh")
	}

	if len(clientRefreshAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ClientRefreshes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &clientRefreshR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.ClientRefreshes = append(local.R.ClientRefreshes, foreign)
				if foreign.R == nil {
					foreign.R = &clientRefreshR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadClientSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadClientSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`client_session`),
		qm.WhereIn(`client_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load client_session")
	}

	var resultSlice []*ClientSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice client_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on client_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for client_session")
	}

	if len(clientSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ClientSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &clientSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.ClientSessions = append(local.R.ClientSessions, foreign)
				if foreign.R == nil {
					foreign.R = &clientSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadEmailVerifySessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadEmailVerifySessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`email_verify_session`),
		qm.WhereIn(`email_verify_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load email_verify_session")
	}

	var resultSlice []*EmailVerifySession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice email_verify_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on email_verify_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for email_verify_session")
	}

	if len(emailVerifySessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EmailVerifySessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emailVerifySessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.EmailVerifySessions = append(local.R.EmailVerifySessions, foreign)
				if foreign.R == nil {
					foreign.R = &emailVerifySessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadLoginClientHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadLoginClientHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`login_client_history`),
		qm.WhereIn(`login_client_history.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load login_client_history")
	}

	var resultSlice []*LoginClientHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice login_client_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on login_client_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for login_client_history")
	}

	if len(loginClientHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoginClientHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loginClientHistoryR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.LoginClientHistories = append(local.R.LoginClientHistories, foreign)
				if foreign.R == nil {
					foreign.R = &loginClientHistoryR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadLoginHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadLoginHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`login_history`),
		qm.WhereIn(`login_history.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load login_history")
	}

	var resultSlice []*LoginHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice login_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on login_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for login_history")
	}

	if len(loginHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoginHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loginHistoryR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.LoginHistories = append(local.R.LoginHistories, foreign)
				if foreign.R == nil {
					foreign.R = &loginHistoryR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadLoginTryHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadLoginTryHistories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`login_try_history`),
		qm.WhereIn(`login_try_history.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load login_try_history")
	}

	var resultSlice []*LoginTryHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice login_try_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on login_try_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for login_try_history")
	}

	if len(loginTryHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LoginTryHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &loginTryHistoryR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.LoginTryHistories = append(local.R.LoginTryHistories, foreign)
				if foreign.R == nil {
					foreign.R = &loginTryHistoryR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOauthSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOauthSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`oauth_session`),
		qm.WhereIn(`oauth_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load oauth_session")
	}

	var resultSlice []*OauthSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice oauth_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on oauth_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for oauth_session")
	}

	if len(oauthSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OauthSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &oauthSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.OauthSessions = append(local.R.OauthSessions, foreign)
				if foreign.R == nil {
					foreign.R = &oauthSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOtpBackups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOtpBackups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`otp_backup`),
		qm.WhereIn(`otp_backup.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load otp_backup")
	}

	var resultSlice []*OtpBackup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice otp_backup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on otp_backup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for otp_backup")
	}

	if len(otpBackupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OtpBackups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &otpBackupR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.OtpBackups = append(local.R.OtpBackups, foreign)
				if foreign.R == nil {
					foreign.R = &otpBackupR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOtpSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOtpSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`otp_session`),
		qm.WhereIn(`otp_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load otp_session")
	}

	var resultSlice []*OtpSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice otp_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on otp_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for otp_session")
	}

	if len(otpSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OtpSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &otpSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.OtpSessions = append(local.R.OtpSessions, foreign)
				if foreign.R == nil {
					foreign.R = &otpSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadRefreshes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadRefreshes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`refresh`),
		qm.WhereIn(`refresh.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load refresh")
	}

	var resultSlice []*Refresh
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice refresh")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on refresh")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for refresh")
	}

	if len(refreshAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Refreshes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &refreshR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Refreshes = append(local.R.Refreshes, foreign)
				if foreign.R == nil {
					foreign.R = &refreshR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadRegisterOtpSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadRegisterOtpSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`register_otp_session`),
		qm.WhereIn(`register_otp_session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load register_otp_session")
	}

	var resultSlice []*RegisterOtpSession
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice register_otp_session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on register_otp_session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for register_otp_session")
	}

	if len(registerOtpSessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RegisterOtpSessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &registerOtpSessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.RegisterOtpSessions = append(local.R.RegisterOtpSessions, foreign)
				if foreign.R == nil {
					foreign.R = &registerOtpSessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadSessions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSessions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`session`),
		qm.WhereIn(`session.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load session")
	}

	var resultSlice []*Session
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice session")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on session")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for session")
	}

	if len(sessionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Sessions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sessionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Sessions = append(local.R.Sessions, foreign)
				if foreign.R == nil {
					foreign.R = &sessionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserBrands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserBrands(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_brand`),
		qm.WhereIn(`user_brand.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_brand")
	}

	var resultSlice []*UserBrand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_brand")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_brand")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_brand")
	}

	if len(userBrandAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserBrands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userBrandR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserBrands = append(local.R.UserBrands, foreign)
				if foreign.R == nil {
					foreign.R = &userBrandR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadWebauthns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadWebauthns(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`webauthn`),
		qm.WhereIn(`webauthn.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load webauthn")
	}

	var resultSlice []*Webauthn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice webauthn")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on webauthn")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for webauthn")
	}

	if len(webauthnAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Webauthns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &webauthnR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Webauthns = append(local.R.Webauthns, foreign)
				if foreign.R == nil {
					foreign.R = &webauthnR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// SetOtp of the user to the related item.
// Sets o.R.Otp to related.
// Adds o to related.R.User.
func (o *User) SetOtp(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Otp) error {
	var err error

	if insert {
		related.UserID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `otp` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
			strmangle.WhereClause("`", "`", 0, otpPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.UserID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			Otp: related,
		}
	} else {
		o.R.Otp = related
	}

	if related.R == nil {
		related.R = &otpR{
			User: o,
		}
	} else {
		related.R.User = o
	}
	return nil
}

// SetPassword of the user to the related item.
// Sets o.R.Password to related.
// Adds o to related.R.User.
func (o *User) SetPassword(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Password) error {
	var err error

	if insert {
		related.UserID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `password` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
			strmangle.WhereClause("`", "`", 0, passwordPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.UserID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			Password: related,
		}
	} else {
		o.R.Password = related
	}

	if related.R == nil {
		related.R = &passwordR{
			User: o,
		}
	} else {
		related.R.User = o
	}
	return nil
}

// SetSetting of the user to the related item.
// Sets o.R.Setting to related.
// Adds o to related.R.User.
func (o *User) SetSetting(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Setting) error {
	var err error

	if insert {
		related.UserID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `setting` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
			strmangle.WhereClause("`", "`", 0, settingPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.UserID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			Setting: related,
		}
	} else {
		o.R.Setting = related
	}

	if related.R == nil {
		related.R = &settingR{
			User: o,
		}
	} else {
		related.R.User = o
	}
	return nil
}

// SetStaff of the user to the related item.
// Sets o.R.Staff to related.
// Adds o to related.R.User.
func (o *User) SetStaff(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Staff) error {
	var err error

	if insert {
		related.UserID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `staff` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
			strmangle.WhereClause("`", "`", 0, staffPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.UserID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			Staff: related,
		}
	} else {
		o.R.Staff = related
	}

	if related.R == nil {
		related.R = &staffR{
			User: o,
		}
	} else {
		related.R.User = o
	}
	return nil
}

// AddBroadcastNotices adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.BroadcastNotices.
// Sets related.R.User appropriately.
func (o *User) AddBroadcastNotices(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*BroadcastNotice) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `broadcast_notice` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, broadcastNoticePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			BroadcastNotices: related,
		}
	} else {
		o.R.BroadcastNotices = append(o.R.BroadcastNotices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &broadcastNoticeR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCertificateSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CertificateSessions.
// Sets related.R.User appropriately.
func (o *User) AddCertificateSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CertificateSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `certificate_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, certificateSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CertificateSessions: related,
		}
	} else {
		o.R.CertificateSessions = append(o.R.CertificateSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &certificateSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddOwnerUserClients adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OwnerUserClients.
// Sets related.R.OwnerUser appropriately.
func (o *User) AddOwnerUserClients(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Client) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerUserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `client` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"owner_user_id"}),
				strmangle.WhereClause("`", "`", 0, clientPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ClientID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerUserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			OwnerUserClients: related,
		}
	} else {
		o.R.OwnerUserClients = append(o.R.OwnerUserClients, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &clientR{
				OwnerUser: o,
			}
		} else {
			rel.R.OwnerUser = o
		}
	}
	return nil
}

// AddClientRefreshes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ClientRefreshes.
// Sets related.R.User appropriately.
func (o *User) AddClientRefreshes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ClientRefresh) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `client_refresh` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, clientRefreshPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ClientRefreshes: related,
		}
	} else {
		o.R.ClientRefreshes = append(o.R.ClientRefreshes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &clientRefreshR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddClientSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ClientSessions.
// Sets related.R.User appropriately.
func (o *User) AddClientSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ClientSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `client_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, clientSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ClientSessions: related,
		}
	} else {
		o.R.ClientSessions = append(o.R.ClientSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &clientSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddEmailVerifySessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.EmailVerifySessions.
// Sets related.R.User appropriately.
func (o *User) AddEmailVerifySessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmailVerifySession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `email_verify_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, emailVerifySessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			EmailVerifySessions: related,
		}
	} else {
		o.R.EmailVerifySessions = append(o.R.EmailVerifySessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emailVerifySessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddLoginClientHistories adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.LoginClientHistories.
// Sets related.R.User appropriately.
func (o *User) AddLoginClientHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoginClientHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `login_client_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, loginClientHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			LoginClientHistories: related,
		}
	} else {
		o.R.LoginClientHistories = append(o.R.LoginClientHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loginClientHistoryR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddLoginHistories adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.LoginHistories.
// Sets related.R.User appropriately.
func (o *User) AddLoginHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoginHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `login_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, loginHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			LoginHistories: related,
		}
	} else {
		o.R.LoginHistories = append(o.R.LoginHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loginHistoryR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddLoginTryHistories adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.LoginTryHistories.
// Sets related.R.User appropriately.
func (o *User) AddLoginTryHistories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LoginTryHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `login_try_history` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, loginTryHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			LoginTryHistories: related,
		}
	} else {
		o.R.LoginTryHistories = append(o.R.LoginTryHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &loginTryHistoryR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddOauthSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OauthSessions.
// Sets related.R.User appropriately.
func (o *User) AddOauthSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OauthSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `oauth_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, oauthSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Code}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			OauthSessions: related,
		}
	} else {
		o.R.OauthSessions = append(o.R.OauthSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &oauthSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddOtpBackups adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OtpBackups.
// Sets related.R.User appropriately.
func (o *User) AddOtpBackups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OtpBackup) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `otp_backup` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, otpBackupPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			OtpBackups: related,
		}
	} else {
		o.R.OtpBackups = append(o.R.OtpBackups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &otpBackupR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddOtpSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OtpSessions.
// Sets related.R.User appropriately.
func (o *User) AddOtpSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OtpSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `otp_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, otpSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			OtpSessions: related,
		}
	} else {
		o.R.OtpSessions = append(o.R.OtpSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &otpSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddRefreshes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Refreshes.
// Sets related.R.User appropriately.
func (o *User) AddRefreshes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Refresh) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `refresh` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, refreshPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Refreshes: related,
		}
	} else {
		o.R.Refreshes = append(o.R.Refreshes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &refreshR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddRegisterOtpSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.RegisterOtpSessions.
// Sets related.R.User appropriately.
func (o *User) AddRegisterOtpSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RegisterOtpSession) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `register_otp_session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, registerOtpSessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			RegisterOtpSessions: related,
		}
	} else {
		o.R.RegisterOtpSessions = append(o.R.RegisterOtpSessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &registerOtpSessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddSessions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Sessions.
// Sets related.R.User appropriately.
func (o *User) AddSessions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Session) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `session` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, sessionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Sessions: related,
		}
	} else {
		o.R.Sessions = append(o.R.Sessions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sessionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserBrands adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserBrands.
// Sets related.R.User appropriately.
func (o *User) AddUserBrands(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserBrand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `user_brand` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, userBrandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserBrands: related,
		}
	} else {
		o.R.UserBrands = append(o.R.UserBrands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userBrandR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddWebauthns adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Webauthns.
// Sets related.R.User appropriately.
func (o *User) AddWebauthns(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Webauthn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `webauthn` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
				strmangle.WhereClause("`", "`", 0, webauthnPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Webauthns: related,
		}
	} else {
		o.R.Webauthns = append(o.R.Webauthns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &webauthnR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("`user`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`user`.*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `user` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from user")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `user` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `user` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `user` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into user")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update user, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update user row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for user")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for user")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

var mySQLUserUniqueColumns = []string{
	"id",
	"user_name",
	"email",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLUserUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert user, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`user`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `user` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for user")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(userType, userMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for user")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for user")
	}

CacheNoHooks:
	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM `user` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for user")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `user`.* FROM `user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `user` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if user exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return UserExists(ctx, exec, o.ID)
}
